/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

import * as path from 'path';
import { workspace, ExtensionContext } from 'vscode';

import {
	LanguageClient,
	LanguageClientOptions,
	ServerOptions,
	TransportKind
} from 'vscode-languageclient';

let client: LanguageClient;

export function activate(context: ExtensionContext) {
	// The server is implemented in node

	let serverModule = context.asAbsolutePath(
		path.join('server', 'out', 'server.js')
	);
	// The debug options for the server
	// --inspect=6009: runs the server in Node's Inspector mode so VS Code can attach to the server for debugging
	let debugOptions = { execArgv: ['--nolazy', '--inspect=6009'] };

	// If the extension is launched in debug mode then the debug server options are used
	// Otherwise the run options are used
	let serverOptions: ServerOptions = {
		run: { module: serverModule, transport: TransportKind.ipc },
		debug: {
			module: serverModule,
			transport: TransportKind.ipc,
			options: debugOptions
		}
	};

	// Options to control the language client
	let clientOptions: LanguageClientOptions = {
		// Register the server for plain text documents
		documentSelector: [{ scheme: 'file', language: 'plaintext' }],
		synchronize: {
			// Notify the server about file changes to '.clientrc files contained in the workspace
			fileEvents: workspace.createFileSystemWatcher('**/.clientrc')
		}
	};

	// Create the language client and start the client.
	client = new LanguageClient(
		'languageServerExample',
		'Language Server Example',
		serverOptions,
		clientOptions
	);

	// Start the client. This will also launch the server
	client.start();
}

export function deactivate(): Thenable<void> | undefined {
	if (!client) {
		return undefined;
	}
	return client.stop();
}
			/*
			else if (appStudioProjectPaths.length > 1) {
				// if there are more than one qml projects in the workspace, prompts the user to select one of them to run the command

				let file = window.activeTextEditor.document.fileName;

				if (window.activeTextEditor !== undefined && appStudioProjectPaths.some(projectPath => path.dirname(file) === projectPath)) {
					runProcess(consoleOutputs, appStudioPath, executable, path.dirname(file));
				} else {
					window.showQuickPick(appStudioProjectPaths, {
						placeHolder: 'Multiple AppStudio projects detected in workspace, please choose one to proceed'
					}).then(folder => {
						if (folder !== undefined) {
							runProcess(consoleOutputs, appStudioPath, executable, folder);
						}
					});
				}

			} else {
				// there is one qml project in the workspace
				runProcess(consoleOutputs, appStudioPath, executable, appStudioProjectPaths[0]);
			}
			*/

import * as vscode from 'vscode';

// this method is called when vs code is activated
export function aactivate(context: vscode.ExtensionContext) {

	console.log('decorator sample is activated');

	// create a decorator type that we use to decorate small numbers
	const smallNumberDecorationType = vscode.window.createTextEditorDecorationType({
		borderWidth: '1px',
		borderStyle: 'solid',
		overviewRulerColor: 'blue',
		overviewRulerLane: vscode.OverviewRulerLane.Right,
		light: {
			// this color will be used in light color themes
			borderColor: 'darkblue'
		},
		dark: {
			// this color will be used in dark color themes
			borderColor: 'lightblue'
		}
	});

	// create a decorator type that we use to decorate large numbers
	const largeNumberDecorationType = vscode.window.createTextEditorDecorationType({
		cursor: 'crosshair',
		// use a themable color. See package.json for the declaration and default values.
		backgroundColor: { id: 'myextension.largeNumberBackground' }
	});

	let activeEditor = vscode.window.activeTextEditor;
	if (activeEditor) {
		triggerUpdateDecorations();
	}

	vscode.window.onDidChangeActiveTextEditor(editor => {
		activeEditor = editor;
		if (editor) {
			triggerUpdateDecorations();
		}
	}, null, context.subscriptions);

	vscode.workspace.onDidChangeTextDocument(event => {
		if (activeEditor && event.document === activeEditor.document) {
			triggerUpdateDecorations();
		}
	}, null, context.subscriptions);

	let timeout : NodeJS.Timer | null = null;
	function triggerUpdateDecorations() {
		if (timeout) {
			clearTimeout(timeout);
		}
		timeout = setTimeout(updateDecorations, 500);
	}

	function updateDecorations() {
		if (!activeEditor) {
			return;
		}
		const regEx = /\d+/g;
		const text = activeEditor.document.getText();
		const smallNumbers: vscode.DecorationOptions[] = [];
		const largeNumbers: vscode.DecorationOptions[] = [];
		let match;
		while (match = regEx.exec(text)) {
			const startPos = activeEditor.document.positionAt(match.index);
			const endPos = activeEditor.document.positionAt(match.index + match[0].length);
			const decoration = { range: new vscode.Range(startPos, endPos), hoverMessage: 'Number **' + match[0] + '**' };
			if (match[0].length < 3) {
				smallNumbers.push(decoration);
			} else {
				largeNumbers.push(decoration);
			}
		}
		activeEditor.setDecorations(smallNumberDecorationType, smallNumbers);
		activeEditor.setDecorations(largeNumberDecorationType, largeNumbers);
	}
}

function addAppStudioProject () {
	appStudioProjectPaths = [];
	activeProjectPath = undefined;

	workspace.findFiles('**/appinfo.json').then(result => {

		if (result.length > 0) {
			result.forEach(uri => {
				//let folderPath = workspace.getWorkspaceFolder(uri).uri.fsPath;

				let projectPath = path.dirname(uri.fsPath);

				fs.readFile(uri.fsPath, (err, data) => {
					if (err) console.log(err);
					let mainFile = JSON.parse(data.toString()).mainFile;
					window.showTextDocument(vscode.Uri.file(path.join(projectPath, mainFile)),
						{
							preview: false
						});
				});
				// use the directory name containing the appinfo.json file found as the project path
				appStudioProjectPaths.push(projectPath);
				activeProjectPath = projectPath;
				activeProjectStatusBar.text = "Active Project: " + path.basename(activeProjectPath);
			});

			noProjectStatusBar.hide();
			for (let item of activeStatusBarItems) {
				item.show();
			}

		} else {

			for (let item of activeStatusBarItems) {
				item.hide();
			}
			
			noProjectStatusBar.text = 'No AppStudio Project found';
			noProjectStatusBar.show();
		}
	});
}

	getChildren(element?: AppStudioTreeItem): Thenable<AppStudioTreeItem[]> {

		let appStudioTreeItem: AppStudioTreeItem [] = [];
		return Promise.resolve(
		vscode.workspace.findFiles('**/appinfo.json').then(result => {

			if (result.length > 0) {
				for (let uri of result) {
					let projectPath = path.dirname(uri.fsPath);

					let iteminfoPath = path.join(projectPath, 'iteminfo.json');

					let data = fs.readFileSync(iteminfoPath);

					let title = JSON.parse(data.toString()).title;

					title += ' (' + path.basename(projectPath) + ')';

					//
					data = fs.readFileSync(uri.fsPath);

					let mainFile = JSON.parse(data.toString()).mainFile;
					let mainfilePath = path.join(projectPath, mainFile);

					vscode.window.showTextDocument(vscode.Uri.file(mainfilePath), {preview: false});

					appStudioTreeItem.push( new AppStudioTreeItem(title, vscode.TreeItemCollapsibleState.None, projectPath, mainfilePath
						/*{ command: 'openMainfile', title: 'Open Mainfile', arguments: [mainfilePath]}*/));
				}
				return appStudioTreeItem;

			} else {
				let noProject = new AppStudioTreeItem('No AppStudio project found.', vscode.TreeItemCollapsibleState.None);
				noProject.contextValue = 'Empty';
				noProject.iconPath = null;
				return [noProject];
			}
		}));
	}


	function getAppStudioProject (): Thenable<vscode.Uri[]> {

		return Promise.resolve(workspace.findFiles('**/appinfo.json').then(result => {
				return result;
		}));
	}

	function addAppStudioProject1(result: vscode.Uri[]) {

		if (result.length > 0) {
			for (let uri of result) {
				let projectPath = path.dirname(uri.fsPath);

				let data = fs.readFileSync(uri.fsPath);

				let mainFile = JSON.parse(data.toString()).mainFile;
				let mainfilePath = path.join(projectPath, mainFile);

				vscode.window.showTextDocument(vscode.Uri.file(mainfilePath), {preview: false});

				activeProjectPath = projectPath;
				projectStatusBar.text = "Active Project: " + path.basename(activeProjectPath);

			}
		} else {
			projectStatusBar.text = 'No AppStudio Project found';
		}
	}

	-------------------------------------------- Codes Before refactor -------------------------------

	// Array containing the paths of all AppStudio projects in the workspace
	//let appStudioProjects: AppStudioProjInfo[];
	//let activeProjectPath: string;

	/*
	let projectsStatus: AppStudioProjStatus = {
		appStudioProjects: [],
		activeProjectPath: undefined
	}

	// Console ouput for the AppStudio Apps
	let consoleOutput = window.createOutputChannel('AppStudio tools stdout');
	let syslogOutput = window.createOutputChannel('AppRun Syslog Message');

	let appStudioTreeView = new AppStudioTreeView(projectsStatus.appStudioProjects);

	let syslogServer;
	if (syslogServer === undefined || !syslogServer.isRunning()) {
		syslogServer = createSyslogServer(syslogOutput);
	}
	let projectStatusBar = window.createStatusBarItem();
	projectStatusBar.show();
	*/

	/*
	projectController.treeView.treeView.onDidChangeSelection( e => {

		if (e.selection.length === 1 && e.selection[0].projectPath) {
			//projectsStatus.activeProjectPath = e.selection[0].projectPath;
			projectController.activeProjectPath = e.selection[0].projectPath;

			for (let proj of projectController.projectInfos) {
				if (proj.projectPath === e.selection[0].projectPath) {
					proj.isActive = true;
				} else {
					proj.isActive = false;
				}
			}
			projectController.treeView.treeData.refresh();

			projectController.projectStatusBar.text = "Active AppStudio Project: " + e.selection[0].label;
		} 
	});

	
	// Add any AppStudio projects when the extension is activated
	getAppStudioProject(appStudioTreeView, projectStatusBar).then( result => {
		projectsStatus.appStudioProjects = result.projects;
		projectsStatus.activeProjectPath = result.path;
		//console.log(activeProjectPath);
	});
	*/


	
	-------------------- Create additional language server for JavaScript

	
	const jsServerOptions: ServerOptions = async () => {
		const childProcess = spawn(process.execPath, [path.resolve(__dirname, '../..', 'javascript-langserver', 'lib', 'language-server-stdio.js')]);
		childProcess.stderr.on('data', (chunk: Buffer) => {
			client.error(chunk + '');
		});
		return childProcess;
	};

	const jsClientOptions: LanguageClientOptions = {
		// Register the server for php documents
		documentSelector: [ 'javascript','js' ],
		uriConverters: {
			// VS Code by default %-encodes even the colon after the drive letter
			// NodeJS handles it much better
			code2Protocol: uri => url.format(url.parse(uri.toString(true))),
			protocol2Code: str => vscode.Uri.parse(str)
		},
		synchronize: {
			// Synchronize the setting section 'php' to the server
			// configurationSection: 'typescript',
			// Notify the server about changes to PHP files in the workspace
			// fileEvents: vscode.workspace.createFileSystemWatcher('**/*.ts')
		}
	};

	let jsClient = new LanguageClient(
		'JSLanguageServer',
		'JS Language Server',
		jsServerOptions,
		jsClientOptions
	);

	jsClient.start();
			